package build

import "core:fmt"
import "core:math/bits"
import "core:os"
import "core:strconv"

// ==============================
//
// Decodes asset files and outputs raw data into `build/assets/*` at compile-time.
// So MUPWIT doesn't decode them at runtime.
//
// ==============================

ASSETS_URI :: "assets/"
FONTS_URI :: ASSETS_URI + "fonts/"
IMAGES_URI :: ASSETS_URI + "images/"

BUILD_ASSETS_URI :: "build/assets/"
BUILD_FONTS_URI :: BUILD_ASSETS_URI + "fonts/"
BUILD_IMAGES_URI :: BUILD_ASSETS_URI + "images/"

main :: proc() {
	if !decode() do os.exit(1)
}

decode :: proc() -> (ok: bool) {
	f := create_file(BUILD_ASSETS_URI + "assets.odin") or_return

	putline(f, "package assets\n")
	putline(f, "import rl \"vendor:raylib\"\n")
	putline(f, "// ==============================")
	putline(f, "// Auto-generated by `build_src/decode_assets.odin`")
	putline(f, "// ==============================\n")

	decode_png(f, "boxes", 2) or_return

	decode_bdf(f, "kaplimono_regular") or_return

	os.flush(f)
	os.close(f)

	return true
}

// ==============================
// Helper functions
// ==============================

create_file :: #force_inline proc(path: string) -> (file: os.Handle, ok: bool) {
	err: os.Error
	file, err = os.open(path, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0o644)
	if err != nil {
		fmt.eprintfln("Unable to create file %s: %s", path, err)
		return 0, false
	}

	return file, true
}

putline :: proc(f: os.Handle, format: string, args: ..any) {
	fmt.fprintfln(f, format, ..args, flush = false)
}

parse_int :: proc(s: string, base := 10) -> Maybe(int) {
	n, ok := strconv.parse_int(s, base)
	if !ok {
		fmt.eprintfln("Unable to parse int from '%s'", s)
		return nil
	}
	return n
}

u32_to_bytes :: proc "contextless" (n: u32) -> [4]byte {
	return transmute([4]byte)bits.to_le_u32(n)
}
i32_to_bytes :: proc "contextless" (n: i32) -> [4]byte {
	return u32_to_bytes(transmute(u32)n)
}
f32_to_bytes :: proc "contextless" (n: f32) -> [4]byte {
	return u32_to_bytes(transmute(u32)n)
}
