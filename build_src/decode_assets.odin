package decode_assets

import "core:fmt"
import "core:math/bits"
import "core:os"
import "core:strconv"

// ==============================
//
// Decodes asset files and outputs raw data into `build/assets/*` at compile-time.
// So MUPWIT doesn't decode them at runtime.
//
// ==============================

ASSETS_URI :: "assets/"
FONTS_URI :: ASSETS_URI + "fonts/"
IMAGES_URI :: ASSETS_URI + "images/"

BUILD_ASSETS_URI :: "build/assets/"
BUILD_FONTS_URI :: BUILD_ASSETS_URI + "fonts/"

main :: proc() {
	f := create_file(BUILD_ASSETS_URI + "assets.odin")
	putline(f, "package assets\n")
	putline(f, "import rl \"vendor:raylib\"\n")
	putline(f, "// ==============================")
	putline(f, "// Auto-generated by `build_src/decode_assets.odin`")
	putline(f, "// ==============================\n")

	decode_bdf(f, "kaplimono_regular")

	os.flush(f)
	os.close(f)
}

// ==============================
// Helper functions
// ==============================

create_file :: #force_inline proc(path: string) -> os.Handle {
	file, err := os.open(path, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0o644)
	if err != nil do panic(fmt.tprintf("Unable to create file %s: %s", path, err))

	return file
}

putline :: proc(f: os.Handle, format: string, args: ..any) {
	fmt.fprintfln(f, format, ..args, flush = false)
}

parse_int :: proc(s: string, base := 10) -> int {
	n, ok := strconv.parse_int(s, base)
	if !ok do panic(fmt.tprintf("Unable to parse int from '%s'", s))
	return n
}

u32_to_bytes :: proc "contextless" (n: u32) -> [4]byte {
	return transmute([4]byte)bits.to_le_u32(n)
}
i32_to_bytes :: proc "contextless" (n: i32) -> [4]byte {
	return u32_to_bytes(transmute(u32)n)
}
f32_to_bytes :: proc "contextless" (n: f32) -> [4]byte {
	return u32_to_bytes(transmute(u32)n)
}
