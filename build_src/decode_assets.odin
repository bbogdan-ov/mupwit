package decode_assets

import "core:fmt"
import "core:math/bits"
import "core:os"
import "core:slice"
import "core:strconv"
import "core:strings"

import rl "vendor:raylib"

// ==============================
//
// Decodes asset files and outputs raw data into `build/assets/*` at compile-time.
// So MUPWIT doesn't decode them at runtime.
//
// ==============================

Bbx :: struct #all_or_none {
	width:  int,
	height: int,
	x:      int,
	y:      int,
}

bbx :: proc() -> Bbx {
	return Bbx{-1, -1, -1, -1}
}

Glyph :: struct #all_or_none {
	codepoint: rune,
	advance_x: int,
	bbx:       Bbx,
	// Glyph rect position relative to the texture's top-left corner.
	rect_pos:  [2]int,
	bitmap:    [dynamic]u32,
}

ASSETS_URI :: "assets/"
FONTS_URI :: ASSETS_URI + "fonts/"

BUILD_ASSETS_URI :: "build/assets/"
BUILD_FONTS_URI :: BUILD_ASSETS_URI + "fonts/"

main :: proc() {
	assets_file := create_file("build/assets/assets.odin")
	putline(assets_file, "package assets\n")
	putline(assets_file, "import rl \"vendor:raylib\"\n")
	putline(assets_file, "// ==============================")
	putline(assets_file, "// Auto generated by `build_src/decode_assets.odin`")
	putline(assets_file, "// ==============================\n")

	decode_bdf_font("kaplimono_regular", assets_file)

	os.flush(assets_file)
	os.close(assets_file)
}

// ==============================
// BDF font
// ==============================

decode_bdf_font :: proc(name: string, assets_file: os.Handle) {
	path := fmt.aprintf(FONTS_URI + "%s.bdf", name)
	defer delete(path)

	glyphs, font_bbx := parse_bdf(path)
	defer delete(glyphs)

	// Render glyphs into the pixels buffer
	PADDING :: 1
	glyphs_width := font_bbx.width - font_bbx.x + PADDING
	glyphs_height := font_bbx.height - font_bbx.y + PADDING

	offset_y := 0

	cap := len(glyphs) * glyphs_width * glyphs_height * 2
	pixels := make([dynamic]byte, len = 0, cap = cap)

	// Render glyphs onto the pixels buffer
	for &glyph in glyphs {
		for row in glyph.bitmap {
			for col_idx := glyphs_width; col_idx > 0; col_idx -= 1 {
				b := (row << PADDING >> uint(col_idx)) & 1
				append(&pixels, 255, byte(b * 255)) // red, alpha
			}
		}

		// Add empty rows for padding
		for _ in 0 ..< glyphs_width * PADDING do append(&pixels, 255, 0)

		glyph.rect_pos.x += 1
		glyph.rect_pos.y = offset_y
		offset_y += glyph.bbx.height + PADDING
	}

	// Generate glyph map
	null_glyph := glyphs[0]
	last_codepoint := slice.last(glyphs[:]).codepoint

	glyph_map := make(map[rune]Glyph, capacity = last_codepoint)
	defer delete(glyph_map)

	// Fill glyph map with null characters
	for codepoint in 0 ..= last_codepoint {
		glyph_map[codepoint] = null_glyph
	}
	for glyph in glyphs {
		assert(glyph.rect_pos.x >= 0)
		assert(glyph.rect_pos.y >= 0)

		glyph_map[glyph.codepoint] = glyph
	}

	{
		// Write raw image data
		outpath := fmt.aprintf(BUILD_FONTS_URI + "%s.rawimage.bin", name)
		file := create_file(outpath)

		_, err := os.write(file, pixels[:])
		if err != nil do panic(fmt.tprint("Unable to write decoded font data:", err))

		os.flush(file)
		os.close(file)
	}

	// Glyphs info and rectangles are stored in a dirties way possible!!!
	// I literally write byte representation of the arrays (glyph info and
	// rectangles arrays) into the binary files, load these files in the app
	// and represent them back as arrays of structs.
	// I'm not even sure it this will work well on 32-bit and/or big endian machines.
	// Do not look at this code, rust people.

	{
		// Write glyphs info
		outpath := fmt.aprintf(BUILD_FONTS_URI + "%s.glyphs.bin", name)
		file := create_file(outpath)

		for codepoint in 0 ..= last_codepoint {
			glyph := &glyph_map[codepoint]

			// FIXME: i'm not sure if byte conversion will work on all machine (especially on 32-bit ones).
			// `rl.GlyphInfo` uses `int`s size of which is tied to the host machine.
			codepoint_bytes := u32_to_bytes(u32(codepoint))
			x_bytes := i32_to_bytes(i32(glyph.bbx.x))
			y_bytes := i32_to_bytes(i32(-glyph.bbx.y))
			advance_x_bytes := i32_to_bytes(i32(glyph.advance_x))

			size :=
				size_of(codepoint_bytes) +
				size_of(x_bytes) +
				size_of(y_bytes) +
				size_of(advance_x_bytes) +
				size_of(rl.Image)
			assert(size == size_of(rl.GlyphInfo))

			os.write(file, codepoint_bytes[:])
			os.write(file, x_bytes[:])
			os.write(file, y_bytes[:])
			os.write(file, advance_x_bytes[:])
			for _ in 0 ..< size_of(rl.Image) {
				os.write_byte(file, 0)
			}
		}

		os.flush(file)
		os.close(file)
	}

	{
		// Write glyphs rectangles
		outpath := fmt.aprintf(BUILD_FONTS_URI + "%s.rects.bin", name)
		file := create_file(outpath)

		for codepoint in 0 ..= last_codepoint {
			glyph := &glyph_map[codepoint]

			x_bytes := f32_to_bytes(f32(glyph.rect_pos.x))
			y_bytes := f32_to_bytes(f32(glyph.rect_pos.y))
			w_bytes := f32_to_bytes(f32(glyph.bbx.width))
			h_bytes := f32_to_bytes(f32(glyph.bbx.height))

			size := size_of(x_bytes) + size_of(y_bytes) + size_of(w_bytes) + size_of(h_bytes)
			assert(size == size_of(rl.Rectangle))

			os.write(file, x_bytes[:])
			os.write(file, y_bytes[:])
			os.write(file, w_bytes[:])
			os.write(file, h_bytes[:])
		}

		os.flush(file)
		os.close(file)
	}

	{
		// Write info about the font
		sheet_height := len(glyphs) * glyphs_height

		f := assets_file
		putline(f, "// Load static '%s' font.", name)
		putline(f, "//")
		putline(f, "// IMPORTANT: you should call `rl.UnloadTexture` instead of `rl.UnloadFont`")
		putline(f, "// because all the data is static, except the texture.")
		putline(f, "font_load_%s :: proc() -> rl.Font {{", name)
		putline(f, "\timage_data := #load(\"fonts/%s.rawimage.bin\")", name)
		putline(f, "\tglyphs     := transmute([]rl.GlyphInfo)#load(\"fonts/%s.glyphs.bin\")", name)
		putline(f, "\trects      := transmute([]rl.Rectangle)#load(\"fonts/%s.rects.bin\")", name)
		putline(f, "")
		putline(f, "\timage := rl.Image {{")
		putline(f, "\t\tdata    = raw_data(image_data),")
		putline(f, "\t\twidth   = %d,", glyphs_width)
		putline(f, "\t\theight  = %d,", sheet_height)
		putline(f, "\t\tmipmaps = 1,")
		putline(f, "\t\tformat  = .UNCOMPRESSED_GRAY_ALPHA,")
		putline(f, "\t}}")
		putline(f, "")
		putline(f, "\ttexture := rl.LoadTextureFromImage(image)")
		putline(f, "")
		putline(f, "\treturn rl.Font {{")
		putline(f, "\t\tbaseSize     = %d,", 16)
		putline(f, "\t\tglyphCount   = %d,", len(glyphs))
		putline(f, "\t\tglyphPadding = %d,", PADDING)
		putline(f, "\t\ttexture      = texture,")
		putline(f, "\t\trecs         = raw_data(rects),")
		putline(f, "\t\tglyphs       = raw_data(glyphs),")
		putline(f, "\t}}")
		putline(f, "}}")
	}
}

parse_bdf :: proc(path: string) -> (glyphs: [dynamic]Glyph, font_bbx: Bbx) {
	data, err := os.read_entire_file_from_filename_or_err(path)
	if err != nil do panic(fmt.tprintf("Unable to read font file %s: %s", path, err))

	text := string(data)
	defer delete(data)

	glyphs = make([dynamic]Glyph, len = 0, cap = 256)

	cur_glyph: Maybe(Glyph) = nil
	is_bitmap := false

	// Parsing the BDF file and collect all the glyphs
	for line in strings.split_lines_iterator(&text) {
		parts := strings.split(line, " ")
		defer delete(parts)

		if glyph, ok := &cur_glyph.?; ok {
			if parts[0] == "ENDCHAR" {
				assert(is_bitmap)

				append(&glyphs, glyph^)

				cur_glyph = nil
				is_bitmap = false
			} else if parts[0] == "ENCODING" {
				assert(len(parts) >= 2)
				glyph.codepoint = rune(parse_int(parts[1]))
			} else if parts[0] == "DWIDTH" {
				assert(len(parts) >= 2)
				glyph.advance_x = parse_int(parts[1])
				assert(glyph.advance_x >= 0)
			} else if parts[0] == "BBX" {
				assert(len(parts) >= 5)
				glyph.bbx.width = parse_int(parts[1])
				glyph.bbx.height = parse_int(parts[2])
				glyph.bbx.x = parse_int(parts[3])
				glyph.bbx.y = parse_int(parts[4]) - (font_bbx.height - glyph.bbx.height)
			} else if parts[0] == "BITMAP" {
				is_bitmap = true
			} else if is_bitmap {
				assert(glyph.bbx.width >= 0)

				n := u32(parse_int(line, 16))

				if glyph.bbx.width <= 8 do assert(n <= 255)
				else if glyph.bbx.width <= 16 do assert(n <= 65535)

				append(&glyph.bitmap, n)
			}
		} else if parts[0] == "STARTCHAR" {
			cur_glyph = Glyph {
				codepoint = -1,
				advance_x = -1,
				bbx       = bbx(),
				rect_pos  = {-1, -1},
				bitmap    = {},
			}
		} else if parts[0] == "FONTBOUNDINGBOX" {
			assert(len(parts) >= 5)
			font_bbx.width = parse_int(parts[1])
			font_bbx.height = parse_int(parts[2])
			font_bbx.x = parse_int(parts[3])
			font_bbx.y = parse_int(parts[4])

			assert(font_bbx.x >= 0)
			assert(font_bbx.width > 0)
			assert(font_bbx.height > 0)
		}
	}

	assert(glyphs[0].codepoint == 0)

	return glyphs, font_bbx
}

// ==============================
// Helper functions
// ==============================

create_file :: #force_inline proc(path: string) -> os.Handle {
	file, err := os.open(path, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0o644)
	if err != nil do panic(fmt.tprintf("Unable to create file %s: %s", path, err))

	return file
}

putline :: proc(f: os.Handle, format: string, args: ..any) {
	fmt.fprintfln(f, format, ..args, flush = false)
}

parse_int :: proc(s: string, base := 10) -> int {
	n, ok := strconv.parse_int(s, base)
	if !ok do panic(fmt.tprintf("Unable to parse int from '%s'", s))
	return n
}

u32_to_bytes :: proc "contextless" (n: u32) -> [4]byte {
	return transmute([4]byte)bits.to_le_u32(n)
}
i32_to_bytes :: proc "contextless" (n: i32) -> [4]byte {
	return u32_to_bytes(transmute(u32)n)
}
f32_to_bytes :: proc "contextless" (n: f32) -> [4]byte {
	return u32_to_bytes(transmute(u32)n)
}

// Output rendered glyphs into the PBM image for debug purposes.
render_to_image :: proc(pixels: []byte, glyphs_width: int) {
	file, err := os.open("build/glyphs.pbm", os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0o644)
	assert(err == nil)

	putline(file, "P1")
	putline(file, "%d %d", glyphs_width, len(pixels) / 2 / glyphs_width)
	for idx in 0 ..< len(pixels) / 2 {
		if pixels[idx * 2 + 1] == 0 {
			putline(file, "0")
		} else {
			putline(file, "1")
		}
	}

	os.flush(file)
	os.close(file)
}
